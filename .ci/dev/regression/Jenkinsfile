@Library('existing-build-control')
import static com.r3.build.BuildControl.killAllExistingBuildsForJob

killAllExistingBuildsForJob(env.JOB_NAME, env.BUILD_NUMBER.toInteger())

pipeline {
    agent { label 'gke' }
    options {
        timestamps()
        buildDiscarder(logRotator(daysToKeepStr: '7', artifactDaysToKeepStr: '7'))
    }

    environment {
        DOCKER_TAG_TO_USE = "${env.GIT_COMMIT.subSequence(0, 8)}"
        EXECUTOR_NUMBER = "${env.EXECUTOR_NUMBER}"
        BUILD_ID = "${env.BUILD_ID}-${env.JOB_NAME}"
        ARTIFACTORY_CREDENTIALS = credentials('artifactory-credentials')
    }

    stages {
    	stage('run 1 test') {
    		steps {
    			sh './gradlew :core-tests:cleanTest :core-tests:test --tests "net.corda.coretests.contracts.AmountParsingTest.testGbpParse"'
    		}
    	}
    }

    post {
        //always {
        //    archiveArtifacts artifacts: '**/pod-logs/**/*.log', fingerprint: false
        //    junit '**/build/test-results-xml/**/*.xml'
        //}

        unsuccessful {

            script {
                def lastCommitterEmail = sh returnStdout: true, script: 'git log -1 --pretty=format:"%ae"'
                echo lastCommitterEmail
                def users = jiraUserSearch queryStr: lastCommitterEmail, site: 'R3 Jira', failOnError: false
                def testIssue = [fields: [ project: [key: 'TM'],
                                         summary: 'Regression build failed for: ' + currentBuild.fullDisplayName,
                                         description: currentBuild.absoluteUrl,
                                         assignee: users.data[0].displayName,
                                         issuetype: [name: 'Story']]]

                response = jiraNewIssue issue: testIssue, site: 'R3 Jira'

                echo response.successful.toString()
                echo response.data.toString()
            }
        }

        cleanup {
            deleteDir() /* clean up our workspace */
        }
    }
}